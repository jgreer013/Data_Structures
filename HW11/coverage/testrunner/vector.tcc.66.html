<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - testrunner</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>testrunner</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2015-11-12 15:14:24</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">35</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">62.9%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">22</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; Vector implementation (out of line) -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 2001-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;* </span>
<span class="lineNum">   26</span>              :  * </span>
<span class="lineNum">   27</span>              :  * Copyright (c) 1994 </span>
<span class="lineNum">   28</span>              :  * Hewlett-Packard Company </span>
<span class="lineNum">   29</span>              :  * </span>
<span class="lineNum">   30</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   31</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   32</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   33</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   34</span>              :  * in supporting documentation.  Hewlett-Packard Company makes no </span>
<span class="lineNum">   35</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   36</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   37</span>              :  * </span>
<span class="lineNum">   38</span>              :  * </span>
<span class="lineNum">   39</span>              :  * Copyright (c) 1996 </span>
<span class="lineNum">   40</span>              :  * Silicon Graphics Computer Systems, Inc. </span>
<span class="lineNum">   41</span>              :  * </span>
<span class="lineNum">   42</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   43</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   44</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   45</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   46</span>              :  * in supporting documentation.  Silicon Graphics makes no </span>
<span class="lineNum">   47</span>              :  * representations about the suitability of this  software for any </span>
<span class="lineNum">   48</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   49</span>              :  *&#047; </span>
<span class="lineNum">   50</span>              :  </span>
<span class="lineNum">   51</span>              : &#047;** @file bits&#047;vector.tcc </span>
<span class="lineNum">   52</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   53</span>              :  *  Do not attempt to use it directly. @headername{vector} </span>
<span class="lineNum">   54</span>              :  *&#047; </span>
<span class="lineNum">   55</span>              :  </span>
<span class="lineNum">   56</span>              : #ifndef _VECTOR_TCC </span>
<span class="lineNum">   57</span>              : #define _VECTOR_TCC 1 </span>
<span class="lineNum">   58</span>              :  </span>
<span class="lineNum">   59</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   60</span>              : { </span>
<span class="lineNum">   61</span>              : _GLIBCXX_BEGIN_NAMESPACE_CONTAINER </span>
<span class="lineNum">   62</span>              :  </span>
<span class="lineNum">   63</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   64</span>              :     void </span>
<span class="lineNum">   65</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">   66</span>              :     reserve(size_type __n) </span>
<span class="lineNum">   67</span>              :     { </span>
<span class="lineNum">   68</span>              :       if (__n &gt; this-&gt;max_size()) </span>
<span class="lineNum">   69</span>              : 	__throw_length_error(__N(&quot;vector::reserve&quot;)); </span>
<span class="lineNum">   70</span>              :       if (this-&gt;capacity() &lt; __n) </span>
<span class="lineNum">   71</span>              : 	{ </span>
<span class="lineNum">   72</span>              : 	  const size_type __old_size = size(); </span>
<span class="lineNum">   73</span>              : 	  pointer __tmp = _M_allocate_and_copy(__n, </span>
<span class="lineNum">   74</span>              : 	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this-&gt;_M_impl._M_start), </span>
<span class="lineNum">   75</span>              : 	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this-&gt;_M_impl._M_finish)); </span>
<span class="lineNum">   76</span>              : 	  std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">   77</span>              : 			_M_get_Tp_allocator()); </span>
<span class="lineNum">   78</span>              : 	  _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">   79</span>              : 			this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">   80</span>              : 			- this-&gt;_M_impl._M_start); </span>
<span class="lineNum">   81</span>              : 	  this-&gt;_M_impl._M_start = __tmp; </span>
<span class="lineNum">   82</span>              : 	  this-&gt;_M_impl._M_finish = __tmp + __old_size; </span>
<span class="lineNum">   83</span>              : 	  this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n; </span>
<span class="lineNum">   84</span>              : 	} </span>
<span class="lineNum">   85</span>              :     } </span>
<span class="lineNum">   86</span>              :  </span>
<span class="lineNum">   87</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">   88</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">   89</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum">   90</span>              :       void </span>
<span class="lineNum">   91</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">   92</span>              :       emplace_back(_Args&amp;&amp;... __args) </span>
<span class="lineNum">   93</span>              :       { </span>
<span class="lineNum">   94</span>              : 	if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage) </span>
<span class="lineNum">   95</span>              : 	  { </span>
<span class="lineNum">   96</span>              : 	    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">   97</span>              : 				     std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">   98</span>              : 	    ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">   99</span>              : 	  } </span>
<span class="lineNum">  100</span>              : 	else </span>
<span class="lineNum">  101</span>              : 	  _M_emplace_back_aux(std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  102</span>              :       } </span>
<span class="lineNum">  103</span>              : #endif </span>
<span class="lineNum">  104</span>              :  </span>
<span class="lineNum">  105</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  106</span>              :     typename vector&lt;_Tp, _Alloc&gt;::iterator </span>
<span class="lineNum">  107</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  108</span>              :     insert(iterator __position, const value_type&amp; __x) </span>
<span class="lineNum">  109</span>              :     { </span>
<span class="lineNum">  110</span>              :       const size_type __n = __position - begin(); </span>
<span class="lineNum">  111</span>              :       if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  112</span>              : 	  &amp;&amp; __position == end()) </span>
<span class="lineNum">  113</span>              : 	{ </span>
<span class="lineNum">  114</span>              : 	  _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, __x); </span>
<span class="lineNum">  115</span>              : 	  ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  116</span>              : 	} </span>
<span class="lineNum">  117</span>              :       else </span>
<span class="lineNum">  118</span>              : 	{ </span>
<span class="lineNum">  119</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  120</span>              : 	  if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage) </span>
<span class="lineNum">  121</span>              : 	    { </span>
<span class="lineNum">  122</span>              : 	      _Tp __x_copy = __x; </span>
<span class="lineNum">  123</span>              : 	      _M_insert_aux(__position, std::move(__x_copy)); </span>
<span class="lineNum">  124</span>              : 	    } </span>
<span class="lineNum">  125</span>              : 	  else </span>
<span class="lineNum">  126</span>              : #endif </span>
<span class="lineNum">  127</span>              : 	    _M_insert_aux(__position, __x); </span>
<span class="lineNum">  128</span>              : 	} </span>
<span class="lineNum">  129</span>              :       return iterator(this-&gt;_M_impl._M_start + __n); </span>
<span class="lineNum">  130</span>              :     } </span>
<span class="lineNum">  131</span>              :  </span>
<span class="lineNum">  132</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  133</span>              :     typename vector&lt;_Tp, _Alloc&gt;::iterator </span>
<span class="lineNum">  134</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  135</span>              :     erase(iterator __position) </span>
<span class="lineNum">  136</span>              :     { </span>
<span class="lineNum">  137</span>              :       if (__position + 1 != end()) </span>
<span class="lineNum">  138</span>              : 	_GLIBCXX_MOVE3(__position + 1, end(), __position); </span>
<span class="lineNum">  139</span>              :       --this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  140</span>              :       _Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish); </span>
<span class="lineNum">  141</span>              :       return __position; </span>
<span class="lineNum">  142</span>              :     } </span>
<span class="lineNum">  143</span>              :  </span>
<span class="lineNum">  144</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  145</span>              :     typename vector&lt;_Tp, _Alloc&gt;::iterator </span>
<span class="lineNum">  146</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  147</span>              :     erase(iterator __first, iterator __last) </span>
<span class="lineNum">  148</span>              :     { </span>
<span class="lineNum">  149</span>              :       if (__first != __last) </span>
<span class="lineNum">  150</span>              : 	{ </span>
<span class="lineNum">  151</span>              : 	  if (__last != end()) </span>
<span class="lineNum">  152</span>              : 	    _GLIBCXX_MOVE3(__last, end(), __first); </span>
<span class="lineNum">  153</span>              : 	  _M_erase_at_end(__first.base() + (end() - __last)); </span>
<span class="lineNum">  154</span>              : 	} </span>
<span class="lineNum">  155</span>              :       return __first; </span>
<span class="lineNum">  156</span>              :     } </span>
<span class="lineNum">  157</span>              :  </span>
<span class="lineNum">  158</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  159</span>              :     vector&lt;_Tp, _Alloc&gt;&amp; </span>
<span class="lineNum">  160</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  161</span>              :     operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x) </span>
<span class="lineNum">  162</span>              :     { </span>
<span class="lineNum">  163</span>              :       if (&amp;__x != this) </span>
<span class="lineNum">  164</span>              : 	{ </span>
<span class="lineNum">  165</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  166</span>              : 	  if (_Alloc_traits::_S_propagate_on_copy_assign()) </span>
<span class="lineNum">  167</span>              : 	    { </span>
<span class="lineNum">  168</span>              : 	      if (!_Alloc_traits::_S_always_equal() </span>
<span class="lineNum">  169</span>              : 	          &amp;&amp; _M_get_Tp_allocator() != __x._M_get_Tp_allocator()) </span>
<span class="lineNum">  170</span>              : 	        { </span>
<span class="lineNum">  171</span>              : 		  &#047;&#047; replacement allocator cannot free existing storage </span>
<span class="lineNum">  172</span>              : 		  this-&gt;clear(); </span>
<span class="lineNum">  173</span>              : 		  _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  174</span>              : 				this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  175</span>              : 				- this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  176</span>              : 		  this-&gt;_M_impl._M_start = nullptr; </span>
<span class="lineNum">  177</span>              : 		  this-&gt;_M_impl._M_finish = nullptr; </span>
<span class="lineNum">  178</span>              : 		  this-&gt;_M_impl._M_end_of_storage = nullptr; </span>
<span class="lineNum">  179</span>              : 		} </span>
<span class="lineNum">  180</span>              : 	      std::__alloc_on_copy(_M_get_Tp_allocator(), </span>
<span class="lineNum">  181</span>              : 				   __x._M_get_Tp_allocator()); </span>
<span class="lineNum">  182</span>              : 	    } </span>
<span class="lineNum">  183</span>              : #endif </span>
<span class="lineNum">  184</span>              : 	  const size_type __xlen = __x.size(); </span>
<span class="lineNum">  185</span>              : 	  if (__xlen &gt; capacity()) </span>
<span class="lineNum">  186</span>              : 	    { </span>
<span class="lineNum">  187</span>              : 	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), </span>
<span class="lineNum">  188</span>              : 						   __x.end()); </span>
<span class="lineNum">  189</span>              : 	      std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  190</span>              : 			    _M_get_Tp_allocator()); </span>
<span class="lineNum">  191</span>              : 	      _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  192</span>              : 			    this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  193</span>              : 			    - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  194</span>              : 	      this-&gt;_M_impl._M_start = __tmp; </span>
<span class="lineNum">  195</span>              : 	      this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __xlen; </span>
<span class="lineNum">  196</span>              : 	    } </span>
<span class="lineNum">  197</span>              : 	  else if (size() &gt;= __xlen) </span>
<span class="lineNum">  198</span>              : 	    { </span>
<span class="lineNum">  199</span>              : 	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), </span>
<span class="lineNum">  200</span>              : 			    end(), _M_get_Tp_allocator()); </span>
<span class="lineNum">  201</span>              : 	    } </span>
<span class="lineNum">  202</span>              : 	  else </span>
<span class="lineNum">  203</span>              : 	    { </span>
<span class="lineNum">  204</span>              : 	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(), </span>
<span class="lineNum">  205</span>              : 			this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  206</span>              : 	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(), </span>
<span class="lineNum">  207</span>              : 					  __x._M_impl._M_finish, </span>
<span class="lineNum">  208</span>              : 					  this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  209</span>              : 					  _M_get_Tp_allocator()); </span>
<span class="lineNum">  210</span>              : 	    } </span>
<span class="lineNum">  211</span>              : 	  this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start + __xlen; </span>
<span class="lineNum">  212</span>              : 	} </span>
<span class="lineNum">  213</span>              :       return *this; </span>
<span class="lineNum">  214</span>              :     } </span>
<span class="lineNum">  215</span>              :  </span>
<span class="lineNum">  216</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  217</span>              :     void </span>
<span class="lineNum">  218</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  219</span>              :     _M_fill_assign(size_t __n, const value_type&amp; __val) </span>
<span class="lineNum">  220</span>              :     { </span>
<span class="lineNum">  221</span>              :       if (__n &gt; capacity()) </span>
<span class="lineNum">  222</span>              : 	{ </span>
<span class="lineNum">  223</span>              : 	  vector __tmp(__n, __val, _M_get_Tp_allocator()); </span>
<span class="lineNum">  224</span>              : 	  __tmp.swap(*this); </span>
<span class="lineNum">  225</span>              : 	} </span>
<span class="lineNum">  226</span>              :       else if (__n &gt; size()) </span>
<span class="lineNum">  227</span>              : 	{ </span>
<span class="lineNum">  228</span>              : 	  std::fill(begin(), end(), __val); </span>
<span class="lineNum">  229</span>              : 	  std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  230</span>              : 					__n - size(), __val, </span>
<span class="lineNum">  231</span>              : 					_M_get_Tp_allocator()); </span>
<span class="lineNum">  232</span>              : 	  this-&gt;_M_impl._M_finish += __n - size(); </span>
<span class="lineNum">  233</span>              : 	} </span>
<span class="lineNum">  234</span>              :       else </span>
<span class="lineNum">  235</span>              :         _M_erase_at_end(std::fill_n(this-&gt;_M_impl._M_start, __n, __val)); </span>
<span class="lineNum">  236</span>              :     } </span>
<span class="lineNum">  237</span>              :  </span>
<span class="lineNum">  238</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  239</span>              :     template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  240</span>              :       void </span>
<span class="lineNum">  241</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  242</span>              :       _M_assign_aux(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">  243</span>              : 		    std::input_iterator_tag) </span>
<span class="lineNum">  244</span>              :       { </span>
<span class="lineNum">  245</span>              : 	pointer __cur(this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  246</span>              : 	for (; __first != __last &amp;&amp; __cur != this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  247</span>              : 	     ++__cur, ++__first) </span>
<span class="lineNum">  248</span>              : 	  *__cur = *__first; </span>
<span class="lineNum">  249</span>              : 	if (__first == __last) </span>
<span class="lineNum">  250</span>              : 	  _M_erase_at_end(__cur); </span>
<span class="lineNum">  251</span>              : 	else </span>
<span class="lineNum">  252</span>              : 	  insert(end(), __first, __last); </span>
<span class="lineNum">  253</span>              :       } </span>
<span class="lineNum">  254</span>              :  </span>
<span class="lineNum">  255</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  256</span>              :     template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">  257</span>              :       void </span>
<span class="lineNum">  258</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  259</span>              :       _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, </span>
<span class="lineNum">  260</span>              : 		    std::forward_iterator_tag) </span>
<span class="lineNum">  261</span>              :       { </span>
<span class="lineNum">  262</span>              : 	const size_type __len = std::distance(__first, __last); </span>
<span class="lineNum">  263</span>              :  </span>
<span class="lineNum">  264</span>              : 	if (__len &gt; capacity()) </span>
<span class="lineNum">  265</span>              : 	  { </span>
<span class="lineNum">  266</span>              : 	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last)); </span>
<span class="lineNum">  267</span>              : 	    std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  268</span>              : 			  _M_get_Tp_allocator()); </span>
<span class="lineNum">  269</span>              : 	    _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  270</span>              : 			  this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  271</span>              : 			  - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  272</span>              : 	    this-&gt;_M_impl._M_start = __tmp; </span>
<span class="lineNum">  273</span>              : 	    this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start + __len; </span>
<span class="lineNum">  274</span>              : 	    this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  275</span>              : 	  } </span>
<span class="lineNum">  276</span>              : 	else if (size() &gt;= __len) </span>
<span class="lineNum">  277</span>              : 	  _M_erase_at_end(std::copy(__first, __last, this-&gt;_M_impl._M_start)); </span>
<span class="lineNum">  278</span>              : 	else </span>
<span class="lineNum">  279</span>              : 	  { </span>
<span class="lineNum">  280</span>              : 	    _ForwardIterator __mid = __first; </span>
<span class="lineNum">  281</span>              : 	    std::advance(__mid, size()); </span>
<span class="lineNum">  282</span>              : 	    std::copy(__first, __mid, this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  283</span>              : 	    this-&gt;_M_impl._M_finish = </span>
<span class="lineNum">  284</span>              : 	      std::__uninitialized_copy_a(__mid, __last, </span>
<span class="lineNum">  285</span>              : 					  this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  286</span>              : 					  _M_get_Tp_allocator()); </span>
<span class="lineNum">  287</span>              : 	  } </span>
<span class="lineNum">  288</span>              :       } </span>
<span class="lineNum">  289</span>              :  </span>
<span class="lineNum">  290</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  291</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  292</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum">  293</span>              :       typename vector&lt;_Tp, _Alloc&gt;::iterator </span>
<span class="lineNum">  294</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  295</span>              :       emplace(iterator __position, _Args&amp;&amp;... __args) </span>
<span class="lineNum">  296</span>              :       { </span>
<span class="lineNum">  297</span>              : 	const size_type __n = __position - begin(); </span>
<span class="lineNum">  298</span>              : 	if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  299</span>              : 	    &amp;&amp; __position == end()) </span>
<span class="lineNum">  300</span>              : 	  { </span>
<span class="lineNum">  301</span>              : 	    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  302</span>              : 				     std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  303</span>              : 	    ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  304</span>              : 	  } </span>
<span class="lineNum">  305</span>              : 	else </span>
<span class="lineNum">  306</span>              : 	  _M_insert_aux(__position, std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  307</span>              : 	return iterator(this-&gt;_M_impl._M_start + __n); </span>
<span class="lineNum">  308</span>              :       } </span>
<span class="lineNum">  309</span>              :  </span>
<span class="lineNum">  310</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  311</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum">  312</span>              :       void </span>
<span class="lineNum">  313</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  314</span>              :       _M_insert_aux(iterator __position, _Args&amp;&amp;... __args) </span>
<span class="lineNum">  315</span>              : #else </span>
<span class="lineNum">  316</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  317</span>              :     void </span>
<span class="lineNum">  318</span><span class="lineCov">      1  /   1:     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  319</span>              :     _M_insert_aux(iterator __position, const _Tp&amp; __x) </span>
<span class="lineNum">  320</span>              : #endif </span>
<span class="lineNum">  321</span>              :     { </span>
<span class="lineNum">  322</span><span class="lineCov">      1  /   1:       if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage) </span>
<span class="lineNum">  323</span>              : 	{ </span>
<span class="lineNum">  324</span><span class="lineNoCov">      0  /   1: 	  _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  325</span>              : 			           _GLIBCXX_MOVE(*(this-&gt;_M_impl._M_finish </span>
<span class="lineNum">  326</span><span class="lineNoCov">      0  /   1: 				                   - 1))); </span>
<span class="lineNum">  327</span><span class="lineNoCov">      0  /   1: 	  ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  328</span>              : #if __cplusplus &lt; 201103L </span>
<span class="lineNum">  329</span><span class="lineNoCov">      0  /   1: 	  _Tp __x_copy = __x; </span>
<span class="lineNum">  330</span>              : #endif </span>
<span class="lineNum">  331</span><span class="lineNoCov">      0  /   1: 	  _GLIBCXX_MOVE_BACKWARD3(__position.base(), </span>
<span class="lineNum">  332</span>              : 				  this-&gt;_M_impl._M_finish - 2, </span>
<span class="lineNum">  333</span>              : 				  this-&gt;_M_impl._M_finish - 1); </span>
<span class="lineNum">  334</span>              : #if __cplusplus &lt; 201103L </span>
<span class="lineNum">  335</span><span class="lineNoCov">      0  /   2: 	  *__position = __x_copy; </span>
<span class="lineNum">  336</span>              : #else </span>
<span class="lineNum">  337</span>              : 	  *__position = _Tp(std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  338</span>              : #endif </span>
<span class="lineNum">  339</span>              : 	} </span>
<span class="lineNum">  340</span>              :       else </span>
<span class="lineNum">  341</span>              : 	{ </span>
<span class="lineNum">  342</span>              : 	  const size_type __len = </span>
<span class="lineNum">  343</span><span class="lineCov">      1  /   1: 	    _M_check_len(size_type(1), &quot;vector::_M_insert_aux&quot;); </span>
<span class="lineNum">  344</span><span class="lineCov">      1  /   1: 	  const size_type __elems_before = __position - begin(); </span>
<span class="lineNum">  345</span><span class="lineCov">      1  /   1: 	  pointer __new_start(this-&gt;_M_allocate(__len)); </span>
<span class="lineNum">  346</span><span class="lineCov">      1  /   1: 	  pointer __new_finish(__new_start); </span>
<span class="lineNum">  347</span>              : 	  __try </span>
<span class="lineNum">  348</span>              : 	    { </span>
<span class="lineNum">  349</span>              : 	      &#047;&#047; The order of the three operations is dictated by the C++0x </span>
<span class="lineNum">  350</span>              : 	      &#047;&#047; case, where the moves could alter a new element belonging </span>
<span class="lineNum">  351</span>              : 	      &#047;&#047; to the existing vector.  This is an issue only for callers </span>
<span class="lineNum">  352</span>              : 	      &#047;&#047; taking the element by const lvalue ref (see 23.1&#047;13). </span>
<span class="lineNum">  353</span><span class="lineCov">      1  /   1: 	      _Alloc_traits::construct(this-&gt;_M_impl, </span>
<span class="lineNum">  354</span>              : 		                       __new_start + __elems_before, </span>
<span class="lineNum">  355</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  356</span>              : 				       std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  357</span>              : #else </span>
<span class="lineNum">  358</span><span class="lineCov">      1  /   1: 	                               __x); </span>
<span class="lineNum">  359</span>              : #endif </span>
<span class="lineNum">  360</span><span class="lineCov">      1  /   1: 	      __new_finish = 0; </span>
<span class="lineNum">  361</span>              :  </span>
<span class="lineNum">  362</span><span class="lineCov">      1  /   1: 	      __new_finish </span>
<span class="lineNum">  363</span>              : 		= std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  364</span>              : 		(this-&gt;_M_impl._M_start, __position.base(), </span>
<span class="lineNum">  365</span><span class="lineCov">      1  /   1: 		 __new_start, _M_get_Tp_allocator()); </span>
<span class="lineNum">  366</span>              :  </span>
<span class="lineNum">  367</span><span class="lineCov">      1  /   1: 	      ++__new_finish; </span>
<span class="lineNum">  368</span>              :  </span>
<span class="lineNum">  369</span><span class="lineCov">      1  /   1: 	      __new_finish </span>
<span class="lineNum">  370</span>              : 		= std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  371</span>              : 		(__position.base(), this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  372</span><span class="lineCov">      1  /   1: 		 __new_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">  373</span>              : 	    } </span>
<span class="lineNum">  374</span><span class="lineNoCov">      0  /   1:           __catch(...) </span>
<span class="lineNum">  375</span>              : 	    { </span>
<span class="lineNum">  376</span><span class="lineNoCov">      0  /   1: 	      if (!__new_finish) </span>
<span class="lineNum">  377</span><span class="lineNoCov">      0  /   1: 		_Alloc_traits::destroy(this-&gt;_M_impl, </span>
<span class="lineNum">  378</span><span class="lineNoCov">      0  /   1: 		                       __new_start + __elems_before); </span>
<span class="lineNum">  379</span>              : 	      else </span>
<span class="lineNum">  380</span><span class="lineNoCov">      0  /   1: 		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">  381</span><span class="lineNoCov">      0  /   1: 	      _M_deallocate(__new_start, __len); </span>
<span class="lineNum">  382</span><span class="lineNoCov">      0  /   1: 	      __throw_exception_again; </span>
<span class="lineNum">  383</span>              : 	    } </span>
<span class="lineNum">  384</span><span class="lineCov">      1  /   1: 	  std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  385</span><span class="lineCov">      1  /   1: 			_M_get_Tp_allocator()); </span>
<span class="lineNum">  386</span><span class="lineCov">      1  /   1: 	  _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  387</span>              : 			this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  388</span><span class="lineCov">      1  /   1: 			- this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  389</span><span class="lineCov">      1  /   1: 	  this-&gt;_M_impl._M_start = __new_start; </span>
<span class="lineNum">  390</span><span class="lineCov">      1  /   1: 	  this-&gt;_M_impl._M_finish = __new_finish; </span>
<span class="lineNum">  391</span><span class="lineCov">      1  /   1: 	  this-&gt;_M_impl._M_end_of_storage = __new_start + __len; </span>
<span class="lineNum">  392</span>              : 	} </span>
<span class="lineNum">  393</span><span class="linePartCov">      2  /   3:     } </span>
<span class="lineNum">  394</span>              :  </span>
<span class="lineNum">  395</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  396</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  397</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum">  398</span>              :       void </span>
<span class="lineNum">  399</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  400</span>              :       _M_emplace_back_aux(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  401</span>              :       { </span>
<span class="lineNum">  402</span>              : 	const size_type __len = </span>
<span class="lineNum">  403</span>              : 	  _M_check_len(size_type(1), &quot;vector::_M_emplace_back_aux&quot;); </span>
<span class="lineNum">  404</span>              : 	pointer __new_start(this-&gt;_M_allocate(__len)); </span>
<span class="lineNum">  405</span>              : 	pointer __new_finish(__new_start); </span>
<span class="lineNum">  406</span>              : 	__try </span>
<span class="lineNum">  407</span>              : 	  { </span>
<span class="lineNum">  408</span>              : 	    _Alloc_traits::construct(this-&gt;_M_impl, __new_start + size(), </span>
<span class="lineNum">  409</span>              : 				     std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  410</span>              : 	    __new_finish = 0; </span>
<span class="lineNum">  411</span>              :  </span>
<span class="lineNum">  412</span>              : 	    __new_finish </span>
<span class="lineNum">  413</span>              : 	      = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  414</span>              : 	      (this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  415</span>              : 	       __new_start, _M_get_Tp_allocator()); </span>
<span class="lineNum">  416</span>              :  </span>
<span class="lineNum">  417</span>              : 	    ++__new_finish; </span>
<span class="lineNum">  418</span>              : 	  } </span>
<span class="lineNum">  419</span>              : 	__catch(...) </span>
<span class="lineNum">  420</span>              : 	  { </span>
<span class="lineNum">  421</span>              : 	    if (!__new_finish) </span>
<span class="lineNum">  422</span>              : 	      _Alloc_traits::destroy(this-&gt;_M_impl, __new_start + size()); </span>
<span class="lineNum">  423</span>              : 	    else </span>
<span class="lineNum">  424</span>              : 	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">  425</span>              : 	    _M_deallocate(__new_start, __len); </span>
<span class="lineNum">  426</span>              : 	    __throw_exception_again; </span>
<span class="lineNum">  427</span>              : 	  } </span>
<span class="lineNum">  428</span>              : 	std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  429</span>              : 		      _M_get_Tp_allocator()); </span>
<span class="lineNum">  430</span>              : 	_M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  431</span>              : 		      this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  432</span>              : 		      - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  433</span>              : 	this-&gt;_M_impl._M_start = __new_start; </span>
<span class="lineNum">  434</span>              : 	this-&gt;_M_impl._M_finish = __new_finish; </span>
<span class="lineNum">  435</span>              : 	this-&gt;_M_impl._M_end_of_storage = __new_start + __len; </span>
<span class="lineNum">  436</span>              :       } </span>
<span class="lineNum">  437</span>              : #endif </span>
<span class="lineNum">  438</span>              :  </span>
<span class="lineNum">  439</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  440</span>              :     void </span>
<span class="lineNum">  441</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  442</span>              :     _M_fill_insert(iterator __position, size_type __n, const value_type&amp; __x) </span>
<span class="lineNum">  443</span>              :     { </span>
<span class="lineNum">  444</span>              :       if (__n != 0) </span>
<span class="lineNum">  445</span>              : 	{ </span>
<span class="lineNum">  446</span>              : 	  if (size_type(this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  447</span>              : 			- this-&gt;_M_impl._M_finish) &gt;= __n) </span>
<span class="lineNum">  448</span>              : 	    { </span>
<span class="lineNum">  449</span>              : 	      value_type __x_copy = __x; </span>
<span class="lineNum">  450</span>              : 	      const size_type __elems_after = end() - __position; </span>
<span class="lineNum">  451</span>              : 	      pointer __old_finish(this-&gt;_M_impl._M_finish); </span>
<span class="lineNum">  452</span>              : 	      if (__elems_after &gt; __n) </span>
<span class="lineNum">  453</span>              : 		{ </span>
<span class="lineNum">  454</span>              : 		  std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n, </span>
<span class="lineNum">  455</span>              : 					      this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  456</span>              : 					      this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  457</span>              : 					      _M_get_Tp_allocator()); </span>
<span class="lineNum">  458</span>              : 		  this-&gt;_M_impl._M_finish += __n; </span>
<span class="lineNum">  459</span>              : 		  _GLIBCXX_MOVE_BACKWARD3(__position.base(), </span>
<span class="lineNum">  460</span>              : 					  __old_finish - __n, __old_finish); </span>
<span class="lineNum">  461</span>              : 		  std::fill(__position.base(), __position.base() + __n, </span>
<span class="lineNum">  462</span>              : 			    __x_copy); </span>
<span class="lineNum">  463</span>              : 		} </span>
<span class="lineNum">  464</span>              : 	      else </span>
<span class="lineNum">  465</span>              : 		{ </span>
<span class="lineNum">  466</span>              : 		  std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  467</span>              : 						__n - __elems_after, </span>
<span class="lineNum">  468</span>              : 						__x_copy, </span>
<span class="lineNum">  469</span>              : 						_M_get_Tp_allocator()); </span>
<span class="lineNum">  470</span>              : 		  this-&gt;_M_impl._M_finish += __n - __elems_after; </span>
<span class="lineNum">  471</span>              : 		  std::__uninitialized_move_a(__position.base(), __old_finish, </span>
<span class="lineNum">  472</span>              : 					      this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  473</span>              : 					      _M_get_Tp_allocator()); </span>
<span class="lineNum">  474</span>              : 		  this-&gt;_M_impl._M_finish += __elems_after; </span>
<span class="lineNum">  475</span>              : 		  std::fill(__position.base(), __old_finish, __x_copy); </span>
<span class="lineNum">  476</span>              : 		} </span>
<span class="lineNum">  477</span>              : 	    } </span>
<span class="lineNum">  478</span>              : 	  else </span>
<span class="lineNum">  479</span>              : 	    { </span>
<span class="lineNum">  480</span>              : 	      const size_type __len = </span>
<span class="lineNum">  481</span>              : 		_M_check_len(__n, &quot;vector::_M_fill_insert&quot;); </span>
<span class="lineNum">  482</span>              : 	      const size_type __elems_before = __position - begin(); </span>
<span class="lineNum">  483</span>              : 	      pointer __new_start(this-&gt;_M_allocate(__len)); </span>
<span class="lineNum">  484</span>              : 	      pointer __new_finish(__new_start); </span>
<span class="lineNum">  485</span>              : 	      __try </span>
<span class="lineNum">  486</span>              : 		{ </span>
<span class="lineNum">  487</span>              : 		  &#047;&#047; See _M_insert_aux above. </span>
<span class="lineNum">  488</span>              : 		  std::__uninitialized_fill_n_a(__new_start + __elems_before, </span>
<span class="lineNum">  489</span>              : 						__n, __x, </span>
<span class="lineNum">  490</span>              : 						_M_get_Tp_allocator()); </span>
<span class="lineNum">  491</span>              : 		  __new_finish = 0; </span>
<span class="lineNum">  492</span>              :  </span>
<span class="lineNum">  493</span>              : 		  __new_finish </span>
<span class="lineNum">  494</span>              : 		    = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  495</span>              : 		    (this-&gt;_M_impl._M_start, __position.base(), </span>
<span class="lineNum">  496</span>              : 		     __new_start, _M_get_Tp_allocator()); </span>
<span class="lineNum">  497</span>              :  </span>
<span class="lineNum">  498</span>              : 		  __new_finish += __n; </span>
<span class="lineNum">  499</span>              :  </span>
<span class="lineNum">  500</span>              : 		  __new_finish </span>
<span class="lineNum">  501</span>              : 		    = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  502</span>              : 		    (__position.base(), this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  503</span>              : 		     __new_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">  504</span>              : 		} </span>
<span class="lineNum">  505</span>              : 	      __catch(...) </span>
<span class="lineNum">  506</span>              : 		{ </span>
<span class="lineNum">  507</span>              : 		  if (!__new_finish) </span>
<span class="lineNum">  508</span>              : 		    std::_Destroy(__new_start + __elems_before, </span>
<span class="lineNum">  509</span>              : 				  __new_start + __elems_before + __n, </span>
<span class="lineNum">  510</span>              : 				  _M_get_Tp_allocator()); </span>
<span class="lineNum">  511</span>              : 		  else </span>
<span class="lineNum">  512</span>              : 		    std::_Destroy(__new_start, __new_finish, </span>
<span class="lineNum">  513</span>              : 				  _M_get_Tp_allocator()); </span>
<span class="lineNum">  514</span>              : 		  _M_deallocate(__new_start, __len); </span>
<span class="lineNum">  515</span>              : 		  __throw_exception_again; </span>
<span class="lineNum">  516</span>              : 		} </span>
<span class="lineNum">  517</span>              : 	      std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  518</span>              : 			    _M_get_Tp_allocator()); </span>
<span class="lineNum">  519</span>              : 	      _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  520</span>              : 			    this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  521</span>              : 			    - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  522</span>              : 	      this-&gt;_M_impl._M_start = __new_start; </span>
<span class="lineNum">  523</span>              : 	      this-&gt;_M_impl._M_finish = __new_finish; </span>
<span class="lineNum">  524</span>              : 	      this-&gt;_M_impl._M_end_of_storage = __new_start + __len; </span>
<span class="lineNum">  525</span>              : 	    } </span>
<span class="lineNum">  526</span>              : 	} </span>
<span class="lineNum">  527</span>              :     } </span>
<span class="lineNum">  528</span>              :  </span>
<span class="lineNum">  529</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  530</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  531</span>              :     void </span>
<span class="lineNum">  532</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  533</span>              :     _M_default_append(size_type __n) </span>
<span class="lineNum">  534</span>              :     { </span>
<span class="lineNum">  535</span>              :       if (__n != 0) </span>
<span class="lineNum">  536</span>              : 	{ </span>
<span class="lineNum">  537</span>              : 	  if (size_type(this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  538</span>              : 			- this-&gt;_M_impl._M_finish) &gt;= __n) </span>
<span class="lineNum">  539</span>              : 	    { </span>
<span class="lineNum">  540</span>              : 	      std::__uninitialized_default_n_a(this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  541</span>              : 					       __n, _M_get_Tp_allocator()); </span>
<span class="lineNum">  542</span>              : 	      this-&gt;_M_impl._M_finish += __n; </span>
<span class="lineNum">  543</span>              : 	    } </span>
<span class="lineNum">  544</span>              : 	  else </span>
<span class="lineNum">  545</span>              : 	    { </span>
<span class="lineNum">  546</span>              : 	      const size_type __len = </span>
<span class="lineNum">  547</span>              : 		_M_check_len(__n, &quot;vector::_M_default_append&quot;); </span>
<span class="lineNum">  548</span>              : 	      const size_type __old_size = this-&gt;size(); </span>
<span class="lineNum">  549</span>              : 	      pointer __new_start(this-&gt;_M_allocate(__len)); </span>
<span class="lineNum">  550</span>              : 	      pointer __new_finish(__new_start); </span>
<span class="lineNum">  551</span>              : 	      __try </span>
<span class="lineNum">  552</span>              : 		{ </span>
<span class="lineNum">  553</span>              : 		  __new_finish </span>
<span class="lineNum">  554</span>              : 		    = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  555</span>              : 		    (this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  556</span>              : 		     __new_start, _M_get_Tp_allocator()); </span>
<span class="lineNum">  557</span>              : 		  std::__uninitialized_default_n_a(__new_finish, __n, </span>
<span class="lineNum">  558</span>              : 						   _M_get_Tp_allocator()); </span>
<span class="lineNum">  559</span>              : 		  __new_finish += __n; </span>
<span class="lineNum">  560</span>              : 		} </span>
<span class="lineNum">  561</span>              : 	      __catch(...) </span>
<span class="lineNum">  562</span>              : 		{ </span>
<span class="lineNum">  563</span>              : 		  std::_Destroy(__new_start, __new_finish, </span>
<span class="lineNum">  564</span>              : 				_M_get_Tp_allocator()); </span>
<span class="lineNum">  565</span>              : 		  _M_deallocate(__new_start, __len); </span>
<span class="lineNum">  566</span>              : 		  __throw_exception_again; </span>
<span class="lineNum">  567</span>              : 		} </span>
<span class="lineNum">  568</span>              : 	      std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  569</span>              : 			    _M_get_Tp_allocator()); </span>
<span class="lineNum">  570</span>              : 	      _M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  571</span>              : 			    this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  572</span>              : 			    - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  573</span>              : 	      this-&gt;_M_impl._M_start = __new_start; </span>
<span class="lineNum">  574</span>              : 	      this-&gt;_M_impl._M_finish = __new_finish; </span>
<span class="lineNum">  575</span>              : 	      this-&gt;_M_impl._M_end_of_storage = __new_start + __len; </span>
<span class="lineNum">  576</span>              : 	    } </span>
<span class="lineNum">  577</span>              : 	} </span>
<span class="lineNum">  578</span>              :     } </span>
<span class="lineNum">  579</span>              :  </span>
<span class="lineNum">  580</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  581</span>              :     bool </span>
<span class="lineNum">  582</span>              :     vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  583</span>              :     _M_shrink_to_fit() </span>
<span class="lineNum">  584</span>              :     { </span>
<span class="lineNum">  585</span>              :       if (capacity() == size()) </span>
<span class="lineNum">  586</span>              : 	return false; </span>
<span class="lineNum">  587</span>              :       return std::__shrink_to_fit_aux&lt;vector&gt;::_S_do_it(*this); </span>
<span class="lineNum">  588</span>              :     } </span>
<span class="lineNum">  589</span>              : #endif </span>
<span class="lineNum">  590</span>              :  </span>
<span class="lineNum">  591</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  592</span>              :     template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  593</span>              :       void </span>
<span class="lineNum">  594</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  595</span>              :       _M_range_insert(iterator __pos, _InputIterator __first, </span>
<span class="lineNum">  596</span>              : 		      _InputIterator __last, std::input_iterator_tag) </span>
<span class="lineNum">  597</span>              :       { </span>
<span class="lineNum">  598</span>              : 	for (; __first != __last; ++__first) </span>
<span class="lineNum">  599</span>              : 	  { </span>
<span class="lineNum">  600</span>              : 	    __pos = insert(__pos, *__first); </span>
<span class="lineNum">  601</span>              : 	    ++__pos; </span>
<span class="lineNum">  602</span>              : 	  } </span>
<span class="lineNum">  603</span>              :       } </span>
<span class="lineNum">  604</span>              :  </span>
<span class="lineNum">  605</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  606</span>              :     template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">  607</span>              :       void </span>
<span class="lineNum">  608</span>              :       vector&lt;_Tp, _Alloc&gt;:: </span>
<span class="lineNum">  609</span>              :       _M_range_insert(iterator __position, _ForwardIterator __first, </span>
<span class="lineNum">  610</span>              : 		      _ForwardIterator __last, std::forward_iterator_tag) </span>
<span class="lineNum">  611</span>              :       { </span>
<span class="lineNum">  612</span>              : 	if (__first != __last) </span>
<span class="lineNum">  613</span>              : 	  { </span>
<span class="lineNum">  614</span>              : 	    const size_type __n = std::distance(__first, __last); </span>
<span class="lineNum">  615</span>              : 	    if (size_type(this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  616</span>              : 			  - this-&gt;_M_impl._M_finish) &gt;= __n) </span>
<span class="lineNum">  617</span>              : 	      { </span>
<span class="lineNum">  618</span>              : 		const size_type __elems_after = end() - __position; </span>
<span class="lineNum">  619</span>              : 		pointer __old_finish(this-&gt;_M_impl._M_finish); </span>
<span class="lineNum">  620</span>              : 		if (__elems_after &gt; __n) </span>
<span class="lineNum">  621</span>              : 		  { </span>
<span class="lineNum">  622</span>              : 		    std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n, </span>
<span class="lineNum">  623</span>              : 						this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  624</span>              : 						this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  625</span>              : 						_M_get_Tp_allocator()); </span>
<span class="lineNum">  626</span>              : 		    this-&gt;_M_impl._M_finish += __n; </span>
<span class="lineNum">  627</span>              : 		    _GLIBCXX_MOVE_BACKWARD3(__position.base(), </span>
<span class="lineNum">  628</span>              : 					    __old_finish - __n, __old_finish); </span>
<span class="lineNum">  629</span>              : 		    std::copy(__first, __last, __position); </span>
<span class="lineNum">  630</span>              : 		  } </span>
<span class="lineNum">  631</span>              : 		else </span>
<span class="lineNum">  632</span>              : 		  { </span>
<span class="lineNum">  633</span>              : 		    _ForwardIterator __mid = __first; </span>
<span class="lineNum">  634</span>              : 		    std::advance(__mid, __elems_after); </span>
<span class="lineNum">  635</span>              : 		    std::__uninitialized_copy_a(__mid, __last, </span>
<span class="lineNum">  636</span>              : 						this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  637</span>              : 						_M_get_Tp_allocator()); </span>
<span class="lineNum">  638</span>              : 		    this-&gt;_M_impl._M_finish += __n - __elems_after; </span>
<span class="lineNum">  639</span>              : 		    std::__uninitialized_move_a(__position.base(), </span>
<span class="lineNum">  640</span>              : 						__old_finish, </span>
<span class="lineNum">  641</span>              : 						this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  642</span>              : 						_M_get_Tp_allocator()); </span>
<span class="lineNum">  643</span>              : 		    this-&gt;_M_impl._M_finish += __elems_after; </span>
<span class="lineNum">  644</span>              : 		    std::copy(__first, __mid, __position); </span>
<span class="lineNum">  645</span>              : 		  } </span>
<span class="lineNum">  646</span>              : 	      } </span>
<span class="lineNum">  647</span>              : 	    else </span>
<span class="lineNum">  648</span>              : 	      { </span>
<span class="lineNum">  649</span>              : 		const size_type __len = </span>
<span class="lineNum">  650</span>              : 		  _M_check_len(__n, &quot;vector::_M_range_insert&quot;); </span>
<span class="lineNum">  651</span>              : 		pointer __new_start(this-&gt;_M_allocate(__len)); </span>
<span class="lineNum">  652</span>              : 		pointer __new_finish(__new_start); </span>
<span class="lineNum">  653</span>              : 		__try </span>
<span class="lineNum">  654</span>              : 		  { </span>
<span class="lineNum">  655</span>              : 		    __new_finish </span>
<span class="lineNum">  656</span>              : 		      = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  657</span>              : 		      (this-&gt;_M_impl._M_start, __position.base(), </span>
<span class="lineNum">  658</span>              : 		       __new_start, _M_get_Tp_allocator()); </span>
<span class="lineNum">  659</span>              : 		    __new_finish </span>
<span class="lineNum">  660</span>              : 		      = std::__uninitialized_copy_a(__first, __last, </span>
<span class="lineNum">  661</span>              : 						    __new_finish, </span>
<span class="lineNum">  662</span>              : 						    _M_get_Tp_allocator()); </span>
<span class="lineNum">  663</span>              : 		    __new_finish </span>
<span class="lineNum">  664</span>              : 		      = std::__uninitialized_move_if_noexcept_a </span>
<span class="lineNum">  665</span>              : 		      (__position.base(), this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  666</span>              : 		       __new_finish, _M_get_Tp_allocator()); </span>
<span class="lineNum">  667</span>              : 		  } </span>
<span class="lineNum">  668</span>              : 		__catch(...) </span>
<span class="lineNum">  669</span>              : 		  { </span>
<span class="lineNum">  670</span>              : 		    std::_Destroy(__new_start, __new_finish, </span>
<span class="lineNum">  671</span>              : 				  _M_get_Tp_allocator()); </span>
<span class="lineNum">  672</span>              : 		    _M_deallocate(__new_start, __len); </span>
<span class="lineNum">  673</span>              : 		    __throw_exception_again; </span>
<span class="lineNum">  674</span>              : 		  } </span>
<span class="lineNum">  675</span>              : 		std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish, </span>
<span class="lineNum">  676</span>              : 			      _M_get_Tp_allocator()); </span>
<span class="lineNum">  677</span>              : 		_M_deallocate(this-&gt;_M_impl._M_start, </span>
<span class="lineNum">  678</span>              : 			      this-&gt;_M_impl._M_end_of_storage </span>
<span class="lineNum">  679</span>              : 			      - this-&gt;_M_impl._M_start); </span>
<span class="lineNum">  680</span>              : 		this-&gt;_M_impl._M_start = __new_start; </span>
<span class="lineNum">  681</span>              : 		this-&gt;_M_impl._M_finish = __new_finish; </span>
<span class="lineNum">  682</span>              : 		this-&gt;_M_impl._M_end_of_storage = __new_start + __len; </span>
<span class="lineNum">  683</span>              : 	      } </span>
<span class="lineNum">  684</span>              : 	  } </span>
<span class="lineNum">  685</span>              :       } </span>
<span class="lineNum">  686</span>              :  </span>
<span class="lineNum">  687</span>              :  </span>
<span class="lineNum">  688</span>              :   &#047;&#047; vector&lt;bool&gt; </span>
<span class="lineNum">  689</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  690</span>              :     void </span>
<span class="lineNum">  691</span>              :     vector&lt;bool, _Alloc&gt;:: </span>
<span class="lineNum">  692</span>              :     _M_reallocate(size_type __n) </span>
<span class="lineNum">  693</span>              :     { </span>
<span class="lineNum">  694</span>              :       _Bit_type* __q = this-&gt;_M_allocate(__n); </span>
<span class="lineNum">  695</span>              :       this-&gt;_M_impl._M_finish = _M_copy_aligned(begin(), end(), </span>
<span class="lineNum">  696</span>              : 						iterator(__q, 0)); </span>
<span class="lineNum">  697</span>              :       this-&gt;_M_deallocate(); </span>
<span class="lineNum">  698</span>              :       this-&gt;_M_impl._M_start = iterator(__q, 0); </span>
<span class="lineNum">  699</span>              :       this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__n); </span>
<span class="lineNum">  700</span>              :     } </span>
<span class="lineNum">  701</span>              :  </span>
<span class="lineNum">  702</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  703</span>              :     void </span>
<span class="lineNum">  704</span>              :     vector&lt;bool, _Alloc&gt;:: </span>
<span class="lineNum">  705</span>              :     _M_fill_insert(iterator __position, size_type __n, bool __x) </span>
<span class="lineNum">  706</span>              :     { </span>
<span class="lineNum">  707</span>              :       if (__n == 0) </span>
<span class="lineNum">  708</span>              : 	return; </span>
<span class="lineNum">  709</span>              :       if (capacity() - size() &gt;= __n) </span>
<span class="lineNum">  710</span>              : 	{ </span>
<span class="lineNum">  711</span>              : 	  std::copy_backward(__position, end(), </span>
<span class="lineNum">  712</span>              : 			     this-&gt;_M_impl._M_finish + difference_type(__n)); </span>
<span class="lineNum">  713</span>              : 	  std::fill(__position, __position + difference_type(__n), __x); </span>
<span class="lineNum">  714</span>              : 	  this-&gt;_M_impl._M_finish += difference_type(__n); </span>
<span class="lineNum">  715</span>              : 	} </span>
<span class="lineNum">  716</span>              :       else </span>
<span class="lineNum">  717</span>              : 	{ </span>
<span class="lineNum">  718</span>              : 	  const size_type __len =  </span>
<span class="lineNum">  719</span>              : 	    _M_check_len(__n, &quot;vector&lt;bool&gt;::_M_fill_insert&quot;); </span>
<span class="lineNum">  720</span>              : 	  _Bit_type * __q = this-&gt;_M_allocate(__len); </span>
<span class="lineNum">  721</span>              : 	  iterator __i = _M_copy_aligned(begin(), __position, </span>
<span class="lineNum">  722</span>              : 					 iterator(__q, 0)); </span>
<span class="lineNum">  723</span>              : 	  std::fill(__i, __i + difference_type(__n), __x); </span>
<span class="lineNum">  724</span>              : 	  this-&gt;_M_impl._M_finish = std::copy(__position, end(), </span>
<span class="lineNum">  725</span>              : 					      __i + difference_type(__n)); </span>
<span class="lineNum">  726</span>              : 	  this-&gt;_M_deallocate(); </span>
<span class="lineNum">  727</span>              : 	  this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len); </span>
<span class="lineNum">  728</span>              : 	  this-&gt;_M_impl._M_start = iterator(__q, 0); </span>
<span class="lineNum">  729</span>              : 	} </span>
<span class="lineNum">  730</span>              :     } </span>
<span class="lineNum">  731</span>              :  </span>
<span class="lineNum">  732</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  733</span>              :     template&lt;typename _ForwardIterator&gt; </span>
<span class="lineNum">  734</span>              :       void </span>
<span class="lineNum">  735</span>              :       vector&lt;bool, _Alloc&gt;:: </span>
<span class="lineNum">  736</span>              :       _M_insert_range(iterator __position, _ForwardIterator __first,  </span>
<span class="lineNum">  737</span>              : 		      _ForwardIterator __last, std::forward_iterator_tag) </span>
<span class="lineNum">  738</span>              :       { </span>
<span class="lineNum">  739</span>              : 	if (__first != __last) </span>
<span class="lineNum">  740</span>              : 	  { </span>
<span class="lineNum">  741</span>              : 	    size_type __n = std::distance(__first, __last); </span>
<span class="lineNum">  742</span>              : 	    if (capacity() - size() &gt;= __n) </span>
<span class="lineNum">  743</span>              : 	      { </span>
<span class="lineNum">  744</span>              : 		std::copy_backward(__position, end(), </span>
<span class="lineNum">  745</span>              : 				   this-&gt;_M_impl._M_finish </span>
<span class="lineNum">  746</span>              : 				   + difference_type(__n)); </span>
<span class="lineNum">  747</span>              : 		std::copy(__first, __last, __position); </span>
<span class="lineNum">  748</span>              : 		this-&gt;_M_impl._M_finish += difference_type(__n); </span>
<span class="lineNum">  749</span>              : 	      } </span>
<span class="lineNum">  750</span>              : 	    else </span>
<span class="lineNum">  751</span>              : 	      { </span>
<span class="lineNum">  752</span>              : 		const size_type __len = </span>
<span class="lineNum">  753</span>              : 		  _M_check_len(__n, &quot;vector&lt;bool&gt;::_M_insert_range&quot;); </span>
<span class="lineNum">  754</span>              : 		_Bit_type * __q = this-&gt;_M_allocate(__len); </span>
<span class="lineNum">  755</span>              : 		iterator __i = _M_copy_aligned(begin(), __position, </span>
<span class="lineNum">  756</span>              : 					       iterator(__q, 0)); </span>
<span class="lineNum">  757</span>              : 		__i = std::copy(__first, __last, __i); </span>
<span class="lineNum">  758</span>              : 		this-&gt;_M_impl._M_finish = std::copy(__position, end(), __i); </span>
<span class="lineNum">  759</span>              : 		this-&gt;_M_deallocate(); </span>
<span class="lineNum">  760</span>              : 		this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len); </span>
<span class="lineNum">  761</span>              : 		this-&gt;_M_impl._M_start = iterator(__q, 0); </span>
<span class="lineNum">  762</span>              : 	      } </span>
<span class="lineNum">  763</span>              : 	  } </span>
<span class="lineNum">  764</span>              :       } </span>
<span class="lineNum">  765</span>              :  </span>
<span class="lineNum">  766</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  767</span>              :     void </span>
<span class="lineNum">  768</span>              :     vector&lt;bool, _Alloc&gt;:: </span>
<span class="lineNum">  769</span>              :     _M_insert_aux(iterator __position, bool __x) </span>
<span class="lineNum">  770</span>              :     { </span>
<span class="lineNum">  771</span>              :       if (this-&gt;_M_impl._M_finish._M_p != this-&gt;_M_impl._M_end_of_storage) </span>
<span class="lineNum">  772</span>              : 	{ </span>
<span class="lineNum">  773</span>              : 	  std::copy_backward(__position, this-&gt;_M_impl._M_finish,  </span>
<span class="lineNum">  774</span>              : 			     this-&gt;_M_impl._M_finish + 1); </span>
<span class="lineNum">  775</span>              : 	  *__position = __x; </span>
<span class="lineNum">  776</span>              : 	  ++this-&gt;_M_impl._M_finish; </span>
<span class="lineNum">  777</span>              : 	} </span>
<span class="lineNum">  778</span>              :       else </span>
<span class="lineNum">  779</span>              : 	{ </span>
<span class="lineNum">  780</span>              : 	  const size_type __len = </span>
<span class="lineNum">  781</span>              : 	    _M_check_len(size_type(1), &quot;vector&lt;bool&gt;::_M_insert_aux&quot;); </span>
<span class="lineNum">  782</span>              : 	  _Bit_type * __q = this-&gt;_M_allocate(__len); </span>
<span class="lineNum">  783</span>              : 	  iterator __i = _M_copy_aligned(begin(), __position, </span>
<span class="lineNum">  784</span>              : 					 iterator(__q, 0)); </span>
<span class="lineNum">  785</span>              : 	  *__i++ = __x; </span>
<span class="lineNum">  786</span>              : 	  this-&gt;_M_impl._M_finish = std::copy(__position, end(), __i); </span>
<span class="lineNum">  787</span>              : 	  this-&gt;_M_deallocate(); </span>
<span class="lineNum">  788</span>              : 	  this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len); </span>
<span class="lineNum">  789</span>              : 	  this-&gt;_M_impl._M_start = iterator(__q, 0); </span>
<span class="lineNum">  790</span>              : 	} </span>
<span class="lineNum">  791</span>              :     } </span>
<span class="lineNum">  792</span>              :  </span>
<span class="lineNum">  793</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  794</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  795</span>              :     bool </span>
<span class="lineNum">  796</span>              :     vector&lt;bool, _Alloc&gt;:: </span>
<span class="lineNum">  797</span>              :     _M_shrink_to_fit() </span>
<span class="lineNum">  798</span>              :     { </span>
<span class="lineNum">  799</span>              :       if (capacity() - size() &lt; int(_S_word_bit)) </span>
<span class="lineNum">  800</span>              : 	return false; </span>
<span class="lineNum">  801</span>              :       __try </span>
<span class="lineNum">  802</span>              : 	{ </span>
<span class="lineNum">  803</span>              : 	  _M_reallocate(size()); </span>
<span class="lineNum">  804</span>              : 	  return true; </span>
<span class="lineNum">  805</span>              : 	} </span>
<span class="lineNum">  806</span>              :       __catch(...) </span>
<span class="lineNum">  807</span>              : 	{ return false; } </span>
<span class="lineNum">  808</span>              :     } </span>
<span class="lineNum">  809</span>              : #endif </span>
<span class="lineNum">  810</span>              :  </span>
<span class="lineNum">  811</span>              : _GLIBCXX_END_NAMESPACE_CONTAINER </span>
<span class="lineNum">  812</span>              : } &#047;&#047; namespace std </span>
<span class="lineNum">  813</span>              :  </span>
<span class="lineNum">  814</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  815</span>              :  </span>
<span class="lineNum">  816</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">  817</span>              : { </span>
<span class="lineNum">  818</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum">  819</span>              :  </span>
<span class="lineNum">  820</span>              :   template&lt;typename _Alloc&gt; </span>
<span class="lineNum">  821</span>              :     size_t </span>
<span class="lineNum">  822</span>              :     hash&lt;_GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&gt;:: </span>
<span class="lineNum">  823</span>              :     operator()(const _GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&amp; __b) const noexcept </span>
<span class="lineNum">  824</span>              :     { </span>
<span class="lineNum">  825</span>              :       size_t __hash = 0; </span>
<span class="lineNum">  826</span>              :       using _GLIBCXX_STD_C::_S_word_bit; </span>
<span class="lineNum">  827</span>              :       using _GLIBCXX_STD_C::_Bit_type; </span>
<span class="lineNum">  828</span>              :  </span>
<span class="lineNum">  829</span>              :       const size_t __words = __b.size() &#047; _S_word_bit; </span>
<span class="lineNum">  830</span>              :       if (__words) </span>
<span class="lineNum">  831</span>              : 	{ </span>
<span class="lineNum">  832</span>              : 	  const size_t __clength = __words * sizeof(_Bit_type); </span>
<span class="lineNum">  833</span>              : 	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength); </span>
<span class="lineNum">  834</span>              : 	} </span>
<span class="lineNum">  835</span>              :  </span>
<span class="lineNum">  836</span>              :       const size_t __extrabits = __b.size() % _S_word_bit; </span>
<span class="lineNum">  837</span>              :       if (__extrabits) </span>
<span class="lineNum">  838</span>              : 	{ </span>
<span class="lineNum">  839</span>              : 	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p; </span>
<span class="lineNum">  840</span>              : 	  __hiword &amp;= ~((~static_cast&lt;_Bit_type&gt;(0)) &lt;&lt; __extrabits); </span>
<span class="lineNum">  841</span>              :  </span>
<span class="lineNum">  842</span>              : 	  const size_t __clength </span>
<span class="lineNum">  843</span>              : 	    = (__extrabits + __CHAR_BIT__ - 1) &#047; __CHAR_BIT__; </span>
<span class="lineNum">  844</span>              : 	  if (__words) </span>
<span class="lineNum">  845</span>              : 	    __hash = std::_Hash_impl::hash(&amp;__hiword, __clength, __hash); </span>
<span class="lineNum">  846</span>              : 	  else </span>
<span class="lineNum">  847</span>              : 	    __hash = std::_Hash_impl::hash(&amp;__hiword, __clength); </span>
<span class="lineNum">  848</span>              : 	} </span>
<span class="lineNum">  849</span>              :  </span>
<span class="lineNum">  850</span>              :       return __hash; </span>
<span class="lineNum">  851</span>              :     } </span>
<span class="lineNum">  852</span>              :  </span>
<span class="lineNum">  853</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum">  854</span>              : } &#047;&#047; namespace std </span>
<span class="lineNum">  855</span>              :  </span>
<span class="lineNum">  856</span>              : #endif &#047;&#047; C++11 </span>
<span class="lineNum">  857</span>              :  </span>
<span class="lineNum">  858</span>              : #endif &#047;* _VECTOR_TCC *&#047; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
